<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Bayesian Method with TensorFlow Chapter5 베이지안 손실함수 - 2. 베이지안 머신러닝 2 - Oh Data Science</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Bayesian Method with TensorFlow Chapter5 베이지안 손실함수 - 2. 베이지안 머신러닝 2" />
<meta property="og:description" content="Bayesian Method with TensorFlow - Chapter5 베이지안 손실함수 #@title Imports and Global Variables (make sure to run this cell) { display-mode: &#34;form&#34; } try: # %tensorflow_version only exists in Colab. %tensorflow_version 2.x except Exception: pass from __future__ import absolute_import, division, print_function #@markdown This sets the warning status (default is `ignore`, since this notebook runs correctly) warning_status = &#34;ignore&#34; #@param [&#34;ignore&#34;, &#34;always&#34;, &#34;module&#34;, &#34;once&#34;, &#34;default&#34;, &#34;error&#34;] import warnings warnings.filterwarnings(warning_status) with warnings.catch_warnings(): warnings." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/bayesianml2/" />
<meta property="article:published_time" content="2020-09-22T14:22:51+09:00" />
<meta property="article:modified_time" content="2020-09-22T14:22:51+09:00" />

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="Oh Data Science" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">Oh Data Science</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Bayesian Method with TensorFlow Chapter5 베이지안 손실함수 - 2. 베이지안 머신러닝 2</h1>
			
		</header><div class="content post__content clearfix">
			<h1 id="bayesian-method-with-tensorflow---chapter5-베이지안-손실함수"><strong>Bayesian Method with TensorFlow - Chapter5 베이지안 손실함수</strong></h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#@title Imports and Global Variables (make sure to run this cell)  { display-mode: &#34;form&#34; }</span>

<span style="color:#66d9ef">try</span>:
  <span style="color:#75715e"># %tensorflow_version only exists in Colab.</span>
  <span style="color:#f92672">%</span>tensorflow_version <span style="color:#ae81ff">2.</span>x
<span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span>:
  <span style="color:#66d9ef">pass</span>


<span style="color:#f92672">from</span> __future__ <span style="color:#f92672">import</span> absolute_import, division, print_function


<span style="color:#75715e">#@markdown This sets the warning status (default is `ignore`, since this notebook runs correctly)</span>
warning_status <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ignore&#34;</span> <span style="color:#75715e">#@param [&#34;ignore&#34;, &#34;always&#34;, &#34;module&#34;, &#34;once&#34;, &#34;default&#34;, &#34;error&#34;]</span>
<span style="color:#f92672">import</span> warnings
warnings<span style="color:#f92672">.</span>filterwarnings(warning_status)
<span style="color:#66d9ef">with</span> warnings<span style="color:#f92672">.</span>catch_warnings():
    warnings<span style="color:#f92672">.</span>filterwarnings(warning_status, category<span style="color:#f92672">=</span><span style="color:#a6e22e">DeprecationWarning</span>)
    warnings<span style="color:#f92672">.</span>filterwarnings(warning_status, category<span style="color:#f92672">=</span><span style="color:#a6e22e">UserWarning</span>)

<span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> os
<span style="color:#75715e">#@markdown This sets the styles of the plotting (default is styled like plots from [FiveThirtyeight.com](https://fivethirtyeight.com/)</span>
matplotlib_style <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;fivethirtyeight&#39;</span> <span style="color:#75715e">#@param [&#39;fivethirtyeight&#39;, &#39;bmh&#39;, &#39;ggplot&#39;, &#39;seaborn&#39;, &#39;default&#39;, &#39;Solarize_Light2&#39;, &#39;classic&#39;, &#39;dark_background&#39;, &#39;seaborn-colorblind&#39;, &#39;seaborn-notebook&#39;]</span>
<span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#f92672">as</span> plt; plt<span style="color:#f92672">.</span>style<span style="color:#f92672">.</span>use(matplotlib_style)
<span style="color:#f92672">import</span> matplotlib.axes <span style="color:#f92672">as</span> axes;
<span style="color:#f92672">from</span> matplotlib.patches <span style="color:#f92672">import</span> Ellipse
<span style="color:#f92672">import</span> matplotlib <span style="color:#f92672">as</span> mpl
<span style="color:#75715e">#%matplotlib inline</span>
<span style="color:#f92672">import</span> seaborn <span style="color:#f92672">as</span> sns; sns<span style="color:#f92672">.</span>set_context(<span style="color:#e6db74">&#39;notebook&#39;</span>)
<span style="color:#f92672">from</span> IPython.core.pylabtools <span style="color:#f92672">import</span> figsize
<span style="color:#75715e">#@markdown This sets the resolution of the plot outputs (`retina` is the highest resolution)</span>
notebook_screen_res <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;retina&#39;</span> <span style="color:#75715e">#@param [&#39;retina&#39;, &#39;png&#39;, &#39;jpeg&#39;, &#39;svg&#39;, &#39;pdf&#39;]</span>
<span style="color:#75715e">#%config InlineBackend.figure_format = notebook_screen_res</span>

<span style="color:#f92672">import</span> tensorflow <span style="color:#f92672">as</span> tf

<span style="color:#f92672">import</span> tensorflow_probability <span style="color:#f92672">as</span> tfp
tfd <span style="color:#f92672">=</span> tfp<span style="color:#f92672">.</span>distributions
tfb <span style="color:#f92672">=</span> tfp<span style="color:#f92672">.</span>bijectors

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_TFColor</span>(object):
    <span style="color:#e6db74">&#34;&#34;&#34;Enum of colors used in TF docs.&#34;&#34;&#34;</span>
    red <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#F15854&#39;</span>
    blue <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#5DA5DA&#39;</span>
    orange <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#FAA43A&#39;</span>
    green <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#60BD68&#39;</span>
    pink <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#F17CB0&#39;</span>
    brown <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#B2912F&#39;</span>
    purple <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#B276B2&#39;</span>
    yellow <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#DECF3F&#39;</span>
    gray <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#4D4D4D&#39;</span>
    <span style="color:#66d9ef">def</span> __getitem__(self, i):
        <span style="color:#66d9ef">return</span> [
            self<span style="color:#f92672">.</span>red,
            self<span style="color:#f92672">.</span>orange,
            self<span style="color:#f92672">.</span>green,
            self<span style="color:#f92672">.</span>blue,
            self<span style="color:#f92672">.</span>pink,
            self<span style="color:#f92672">.</span>brown,
            self<span style="color:#f92672">.</span>purple,
            self<span style="color:#f92672">.</span>yellow,
            self<span style="color:#f92672">.</span>gray,
        ][i <span style="color:#f92672">%</span> <span style="color:#ae81ff">9</span>]
TFColor <span style="color:#f92672">=</span> _TFColor()

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">session_options</span>(enable_gpu_ram_resizing<span style="color:#f92672">=</span>True, enable_xla<span style="color:#f92672">=</span>False):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Allowing the notebook to make use of GPUs if they&#39;re available.
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">    XLA (Accelerated Linear Algebra) is a domain-specific compiler for linear
</span><span style="color:#e6db74">    algebra that optimizes TensorFlow computations.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    config <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>config
    gpu_devices <span style="color:#f92672">=</span> config<span style="color:#f92672">.</span>experimental<span style="color:#f92672">.</span>list_physical_devices(<span style="color:#e6db74">&#39;GPU&#39;</span>)
    <span style="color:#66d9ef">if</span> enable_gpu_ram_resizing:
        <span style="color:#66d9ef">for</span> device <span style="color:#f92672">in</span> gpu_devices:
           tf<span style="color:#f92672">.</span>config<span style="color:#f92672">.</span>experimental<span style="color:#f92672">.</span>set_memory_growth(device, True)
    <span style="color:#66d9ef">if</span> enable_xla:
        config<span style="color:#f92672">.</span>optimizer<span style="color:#f92672">.</span>set_jit(True)
    <span style="color:#66d9ef">return</span> config

session_options(enable_gpu_ram_resizing<span style="color:#f92672">=</span>True, enable_xla<span style="color:#f92672">=</span>True)

<span style="color:#960050;background-color:#1e0010">!</span>apt <span style="color:#f92672">-</span>qq <span style="color:#f92672">-</span>y install fonts<span style="color:#f92672">-</span>nanum
 
<span style="color:#f92672">import</span> matplotlib.font_manager <span style="color:#f92672">as</span> fm
fontpath <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;/usr/share/fonts/truetype/nanum/NanumBarunGothic.ttf&#39;</span>
font <span style="color:#f92672">=</span> fm<span style="color:#f92672">.</span>FontProperties(fname<span style="color:#f92672">=</span>fontpath, size<span style="color:#f92672">=</span><span style="color:#ae81ff">9</span>)
plt<span style="color:#f92672">.</span>rc(<span style="color:#e6db74">&#39;font&#39;</span>, family<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;NanumBarunGothic&#39;</span>) 
mpl<span style="color:#f92672">.</span>font_manager<span style="color:#f92672">.</span>_rebuild()
</code></pre></div><pre><code>The following NEW packages will be installed:
  fonts-nanum
0 upgraded, 1 newly installed, 0 to remove and 11 not upgraded.
Need to get 9,604 kB of archives.
After this operation, 29.5 MB of additional disk space will be used.
Selecting previously unselected package fonts-nanum.
(Reading database ... 144676 files and directories currently installed.)
Preparing to unpack .../fonts-nanum_20170925-1_all.deb ...
Unpacking fonts-nanum (20170925-1) ...
Setting up fonts-nanum (20170925-1) ...
Processing triggers for fontconfig (2.12.6-0ubuntu2) ...
</code></pre>
<h1 id="3-베이지안-머신러닝-2">3. 베이지안 머신러닝 2</h1>
<h1 id="예제--암흑-물질-탐색-캐글-콘테스트">예제 : 암흑 물질 탐색 캐글 콘테스트</h1>
<p><a href="http://www.kaggle.com/c/DarkWorlds"><em>Observing Dark Worlds</em></a> 콘테스트 웹사이트에서 이 콘테스트에 대해 다음과 같이 설명했습니다.</p>
<blockquote>
<p>우주에는 눈에 보이는 것 보다 더 많은 것이 있습니다. 우주 밖에 존재하는 물체들은 우리가 볼 수 있는 것들보다 7배나 많고, 그것들이 무엇인지 우리들은 모릅니다. 우리가 아는 유일한 것은 그것들이 빛을 내보내거나 흡수하지 않는다는 것입니다. 그래서 그것을 암흑물질 이라고 부릅니다. 그정도로 거대한 양이 모인 물질은 눈에 띄지 않을 수 없습니다. 사실 우리는 암흑 물질 헤일로라고 불리는 이 물질이 모이고 거대한 구조를 관측했습니다. 이것이 &lsquo;암흑&rsquo;이긴 하지만, 암흑 물질을 지나는 뒤에 있는 은하들의 빛의 경로를 휘게 하고 왜곡합니다. 이러한 빛의 휨은 하늘에 은하수가 타원형으로 나타나게 합니다.</p>
</blockquote>
<p>이 컨테스트는 어디에 암흑 물질이 있을 확률이 높을지를 예측하는 것입니다. 1등을 차지한 Tim Salimans는 헤일로의 위치를 찾기 위해 베이지안 추론을 사용했습니다.(흥미롭게도 2등을 한 사람도 베이지안 추론을 사용했습니다.) 이 포스트에서는 Tim의 제출물을 통해 그의 답안을 소개하도록 하겠습니다.</p>
<ol>
<li>헤일로 위치 $p(x)$에 대한 사전 분포를 만듭니다. 즉 데이터를 보기 전에 헤일로 위치에 대한 우리의 예측을 형성합니다.</li>
<li>암흑 물질 헤일로의 위치가 주어졌을 때 데이터(관측된 은하들의 타원인 정도) 의 확률론적인 모델 $p(e|x)$을 만듭니다.</li>
<li>베이즈 룰을 사용해 헤일로 위치의 사후 분포를 만듭니다. 즉 데이터를 사용해 암흑 물질 헤일로가 어디에 있을지 추측합니다.</li>
<li>헤일로 위치를 예측하는 사후 분포의 측면에서 기대 손실을 최소화합니다. 식으로 나타내면 다음과 같습니다. $\hat{x} = \arg \min_{\text{prediction} } E_{p(x|e)}[ L( \text{prediction}, x) ]$ 즉 주어진 오류 지표에 대해 우리의 예측값들을 최대한 좋게 만듭니다.</li>
</ol>
<p>이 문제에서의 손실 함수는 아주 복잡합니다. <a href="https://github.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/tree/master/Chapter5_LossFunctions">https://github.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/tree/master/Chapter5_LossFunctions</a> 여기에 있는 DarkWorldsMetric.py 파일에 손실함수가 포함되어있지만, 전부를 읽어볼 필요는 없습니다. 단지 그 손실 함수가 하나의 수식으로 나타낼 수 있는 것이 아니라 160줄의 코드로 이루어져있다는 것만 알면 됩니다. 그 손실함수는 이동-편향(shift-bias)가 나타나지 않는 유클리디안 거리의 측면으로 예측의 정확도(accuracy)를 측정합니다. 이 지표에 대해 더 자세한 내용은 <a href="http://www.kaggle.com/c/DarkWorlds/details/evaluation">main page</a> 이곳을 참조하세요.</p>
<p>이 포스트에서는 Tim의 1등 코드를 TFP와 손실함수에 대한 지식을 사용해 실행해보도록 하겠습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">pip install wget
</code></pre></div><pre><code>Collecting wget
  Downloading https://files.pythonhosted.org/packages/47/6a/62e288da7bcda82b935ff0c6cfe542970f04e29c756b0e147251b2fb251f/wget-3.2.zip
Building wheels for collected packages: wget
  Building wheel for wget (setup.py) ... [?25l[?25hdone
  Created wheel for wget: filename=wget-3.2-cp36-none-any.whl size=9682 sha256=72fa99a48396277339738570f978d7bf7ee417f0afe55ec922ace9b3308be3d3
  Stored in directory: /root/.cache/pip/wheels/40/15/30/7d8f7cea2902b4db79e3fea550d7d7b85ecb27ef992b618f3f
Successfully built wget
Installing collected packages: wget
Successfully installed wget-3.2
</code></pre>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> wget

<span style="color:#75715e"># Galaxy Data 다운로드</span>
url1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;https://github.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/blob/master/Chapter5_LossFunctions/data.zip?raw=true&#39;</span>
filename1 <span style="color:#f92672">=</span> wget<span style="color:#f92672">.</span>download(url1)
filename1
</code></pre></div><pre><code>'data.zip'
</code></pre>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#960050;background-color:#1e0010">!</span>unzip <span style="color:#f92672">-</span>q data<span style="color:#f92672">.</span>zip <span style="color:#f92672">-</span>d data
</code></pre></div><p>우리는 또한 이 캐글 대회만을 위한 데이터 파일들과 손실 함수들을 가져와야 합니다. 당신은 이 파일들을 <a href="https://www.kaggle.com/c/DarkWorlds/data">Observing Dark Worlds competition&rsquo;s Data page</a> 이곳에서 직접적으로 가져오거나, 만일 당신이 캐글 계정이 있다면 <a href="https://github.com/Kaggle/kaggle-api">Kaggle API</a> 를 다운로드하고 다음과 같은 터미널 명령어를 실행하시면 됩니다.</p>
<pre><code>kaggle competitions download -c DarkWorlds
</code></pre><p>대회 정보가 본인의 컴퓨터에서 사용 가능하다면, 간단하게 데이터의 압축을 풀 수 있습니다.</p>
<h3 id="은하수-도표-그리기-함수-정의"><strong>은하수 도표 그리기 함수 정의</strong></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">draw_sky</span>(galaxies):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    주어진 은하수 데이터를 통해 은하수의 모양과 위치를 그래프로 그립시다.
</span><span style="color:#e6db74">    
</span><span style="color:#e6db74">    Args:
</span><span style="color:#e6db74">      galaxies: 4개의 칼럼을 지닌 float32 Numpy array. 네 개의 칼럼은 각각
</span><span style="color:#e6db74">      x-coordinates, y-coordinates,
</span><span style="color:#e6db74">      그리고 두 개 축의 타원도.
</span><span style="color:#e6db74">    Returns:
</span><span style="color:#e6db74">      fig: 은하수 도표 이미지
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    size_multiplier <span style="color:#f92672">=</span> <span style="color:#ae81ff">45</span>
    fig <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>))
    ax <span style="color:#f92672">=</span> fig<span style="color:#f92672">.</span>add_subplot(<span style="color:#ae81ff">111</span>, aspect<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;equal&#39;</span>)
    n <span style="color:#f92672">=</span> galaxies<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
        g <span style="color:#f92672">=</span> galaxies[i,:]
        x, y <span style="color:#f92672">=</span> g[<span style="color:#ae81ff">0</span>], g[<span style="color:#ae81ff">1</span>]
        d <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>sqrt(g[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> g[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span>)
        a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> d)
        b <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> d)
        theta <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>degrees( np<span style="color:#f92672">.</span>arctan2( g[<span style="color:#ae81ff">3</span>], g[<span style="color:#ae81ff">2</span>])<span style="color:#f92672">*</span><span style="color:#ae81ff">0.5</span> )
        
        ax<span style="color:#f92672">.</span>add_patch(Ellipse(xy<span style="color:#f92672">=</span>(x, y), width<span style="color:#f92672">=</span>size_multiplier <span style="color:#f92672">*</span> a, height<span style="color:#f92672">=</span>size_multiplier <span style="color:#f92672">*</span> b, angle<span style="color:#f92672">=</span>theta))
    ax<span style="color:#f92672">.</span>autoscale_view(tight<span style="color:#f92672">=</span>True)
    
    <span style="color:#66d9ef">return</span> fig
</code></pre></div><h2 id="데이터-둘러보기"><strong>데이터 둘러보기</strong></h2>
<p>이 데이터셋은 300개의 독립된 파일들로 이루어져있습니다. 각각은 하늘을 표현하죠. 각각의 파일 또는 하늘에 300개와 720개 사이의 은하수들이 있습니다. 각각의 은하수는 0부터 4200 사이의 위치를 나타내는 $x, y$, 그리고 타원도를 측정하는 $e_1, e_2$를 가지고 있습니다. <a href="https://www.kaggle.com/c/DarkWorlds/details/an-introduction-to-ellipticity">여기</a>에 이러한 측도들이 무엇인지에 대한 정보가 담겨있습니다. 그러나 우리의 목표를 위해서는 시각화의 목적 빼고는 필요 없습니다. 따라서 특정한 하늘은 다음과 같이 생겼습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">n_sky <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>             <span style="color:#75715e">#어떤 파일을 볼지 선택</span>
data <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>genfromtxt(<span style="color:#e6db74">&#34;data/Train_Skies/Train_Skies/</span><span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span><span style="color:#e6db74">Training_Sky</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">.csv&#34;</span> <span style="color:#f92672">%</span> (n_sky),
                      dtype <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>float32,
                      skip_header <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
                      delimiter <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;,&#34;</span>,
                      usecols <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>])
              <span style="color:#75715e"># 데이터를 불러올 때 타입을 설정해주는게 편합니다.</span>

galaxy_positions <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(data[:, :<span style="color:#ae81ff">2</span>], dtype<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>float32)
gal_ellipticities <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(data[:, <span style="color:#ae81ff">2</span>:], dtype<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>float32)
ellipticity_mean <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>mean(data[:, <span style="color:#ae81ff">2</span>:], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
ellipticity_stddev <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>std(data[:, <span style="color:#ae81ff">2</span>:], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
num_galaxies <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(galaxy_positions)<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;하늘에 있는 은하수들의 데이터 </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">.&#34;</span><span style="color:#f92672">%</span>n_sky)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;position_x, position_y, e_1, e_2 &#34;</span>)
<span style="color:#66d9ef">print</span>(data[:<span style="color:#ae81ff">3</span>])
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;은하들의 갯수: &#34;</span>, num_galaxies)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;e_1 &amp; e_2 평균: &#34;</span>, ellipticity_mean)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;e_1 &amp; e_2 표준편차: &#34;</span>, ellipticity_stddev)
</code></pre></div><pre><code>하늘에 있는 은하수들의 데이터 3.
position_x, position_y, e_1, e_2 
[[ 1.62690e+02  1.60006e+03  1.14664e-01 -1.90326e-01]
 [ 2.27228e+03  5.40040e+02  6.23555e-01  2.14979e-01]
 [ 3.55364e+03  2.69771e+03  2.83527e-01 -3.01870e-01]]
은하들의 갯수:  578
e_1 &amp; e_2 평균:  [ 0.01398942 -0.00522833]
e_1 &amp; e_2 표준편차:  [0.23272723 0.22050022]
</code></pre>
<p>좋습니다. 위에서 볼 수 있듯이 각 은하수들의 위치를 나타내는 $x, y$, 그리고 타원 정도를 나타내는 $e_1, e_2$로 이루어진 네 개의 칼럼들로 데이터가 이루어져있습니다. 만일 우리가 위치에 대해 직접적으로 알아보길 원한다면, 다음과 같이 하면 됩니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">fig <span style="color:#f92672">=</span> draw_sky(data)
plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;Galaxy positions and ellipcities of sky </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">.&#34;</span> <span style="color:#f92672">%</span> n_sky)
plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;x-position&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;y-position&#34;</span>);
</code></pre></div><pre><code>findfont: Font family ['NanumBarunGothic'] not found. Falling back to DejaVu Sans.
findfont: Font family ['NanumBarunGothic'] not found. Falling back to DejaVu Sans.
</code></pre>
<p><img src="https://user-images.githubusercontent.com/57588650/93846441-ff09e800-fcde-11ea-9bd0-f8a18942bacd.png" alt="output_17_1"></p>
<p>아름답군요&hellip;.!</p>
<h2 id="사전-분포"><strong>사전 분포</strong></h2>
<p>각각의 하늘은 1,2 또는 3개의 암흑 물질 헤일로를 가지고 있습니다. Tim의 답안에서는 헤일로의 위치가 다음과 같이 $\text{Uniform}$ 분포를 따른다고 가정했습니다.</p>
<p>$$
\begin{align}
&amp; x_i \sim \text{Uniform}( 0, 4200)\<br>
&amp; y_i \sim \text{Uniform}( 0, 4200), \ \ i=1,2,3\<br>
\end{align}
$$</p>
<p>Tim과 다른 참가자들은 대부분의 하늘이 하나의 큰 헤일로와 다른 더 작은 헤일로들을 가지고 있다는걸 알아냈습니다. 더 큰 헤일로일 수록 둘러싼 은하들에게 더 큰 영향을 줄 것입니다. 그는 큰 헤일로들이 다음과 같이 40과 180 사이의 로그 균등 확률 변수로 그 크기가 분포되어있다고 정했습니다.</p>
<p>$$  m_{\text{large} } = \log \text{Uniform}( 40, 180 ) $$</p>
<p>그리고 이것을 TFP로 나타내면 다음과 같습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Log-Uniform Distribution</span>
mass_large <span style="color:#f92672">=</span> tfd<span style="color:#f92672">.</span>TransformedDistribution(
    distribution<span style="color:#f92672">=</span>tfd<span style="color:#f92672">.</span>Uniform(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;exp_mass_large&#34;</span>, low<span style="color:#f92672">=</span><span style="color:#ae81ff">40.0</span>, high<span style="color:#f92672">=</span><span style="color:#ae81ff">180.0</span>),
    bijector<span style="color:#f92672">=</span>tfb<span style="color:#f92672">.</span>Exp())
</code></pre></div><p>(이것이 바로 로그-균등(log-uniform)이라고 불리는 것입니다.) 작은 은하들에 대해서 Tim은 그 크기를 로그 20으로 정했습니다. 왜 Tim이 작은 은하들에 사전 분포를 만들지 않고 미지수로 다루지 않았을까요? 저는 이 이유가 알고리즘의 수렴 속도를 높이기 위한 것이라고 생각합니다. 작은 헤일로들은 은하들에게 그만큼 작은 영향을 끼치기 때문에 지나치게 제한적이라곤 할 수 없습니다.</p>
<p>Tim은 논리적으로 각각의 은하의 타원도가 헤일로의 위치, 은하와 헤일로 사이의 거리, 그리고 헤일로의 크기에 의존한다고 가정했습니다. 따라서 각각의 은하의 타원도 벡터 $e_i$는 헤일로 위치 $(x, y)$, 거리(식으로 만들겁니다), 그리고 헤일로 크기의 자손 변수(children variable)라고 할 수 있습니다.</p>
<p>Tim은 논문과 포럼의 게시물에서 헤일로의 위치와 타원율 간의 관계에 대해 다음과 같은 식을 만들었습니다.</p>
<p>$$ e_i | ( \mathbf{x}, \mathbf{y} ) \sim \text{Normal}( \sum_{j = \text{halo positions} }d_{i,j} m_j f( r_{i,j} ), \sigma^2 ) $$</p>
<p>여기서 $d_{i,j}$은 헤일로 $j$가 은하 $i$에서 나온 빛을 구부리는 방향인 *접선 방향(Tangential Direction)이고, $m_j$는 헤일로 $j$의 크기를, $f(r_{i,j})$는 헤일로 $j$와 은하 $i$사이의 유클리디안 거리의 감소함수(decreasing function)입니다.</p>
<p>분산 $\sigma^2$는 간단하게 0.05라고 추정하겠습니다. 이것은 $e_i$ 측정값의 표준편차가 $i$ 전체에 대해 대략 0.223607&hellip;라는 것을 의미합니다.</p>
<p>Tim의 함수 $f$는 큰 헤일로의 경우는 다음과 같이 정의됩니다.</p>
<p>$$ f( r_{i,j} ) = \frac{1}{\min( r_{i,j}, 240 ) } $$</p>
<p>작은 헤일로에선 다음과 같습니다.</p>
<p>$$ f( r_{i,j} ) = \frac{1}{\min( r_{i,j}, 70 ) } $$</p>
<p>이것은 우리의 관측값과 미지수 사이를 완벽하게 연결합니다. 이 모델은 매우 쉽습니다. 그리고 Tim은 과적합을 방지하기 위해 이러한 단순함을 의도하고 모델을 만들었다고 말했습니다.</p>
<h2 id="모델-학습--tensorflow로-이식"><strong>모델 학습 &amp; TensorFlow로 이식</strong></h2>
<p>각각의 하늘에서, 우리는 알려진 헤일로의 위치는 무시하고 헤일로 위치의 사후 분포를 찾기 위해 우리의 베이지안 모델을 돌릴 것입니다. 이것은 아마 전통적인 캐글 대회의 접근 방식과는 다를겁니다. 이 모델이 다른 하늘들과 알려진 헤일로의 위치에 대한 데이터를 사용하지 않기 때문이죠. 이게 다른 데이터가 필요하지 않다는 것은 아닙니다. 사실 이 모델은 여러 다른 하늘들을 비교하면서 만든 것입니다.</p>
<p><strong>헤일로 위치 $p(x)$에 사전 분포를 만드는 것은 데이터를 보기 전에 헤일로의 위치에 대한 우리들의 예측값을 만드는 것입니다.</strong></p>
<p>우리들의 사전 분포와 likelihood 분포를 만들 때, 우리는 이것들을 <a href="https://github.com/tensorflow/probability/blob/master/tensorflow_probability/examples/vae.py">Variational Auto Encoder</a> 과 아주 비슷한 손실함수를 만들 때 사용할 것입니다.(물론 더 낮은 차원의 것입니다.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">euclidean_distance</span>(x, y):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    지점 x와 y 사이의 유클리디안 거리를 계싼합니다.
</span><span style="color:#e6db74">    
</span><span style="color:#e6db74">    Args:
</span><span style="color:#e6db74">      x: 원소간 계산을 위한 Tensorflow Tensor
</span><span style="color:#e6db74">      y: 원소간 계산을 위한 Tensorflow Tensor
</span><span style="color:#e6db74">    Returns: 
</span><span style="color:#e6db74">      x와 y 사이의 유클리디안 거리를 포함한 텐서
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">return</span> tf<span style="color:#f92672">.</span>sqrt(tf<span style="color:#f92672">.</span>reduce_sum(tf<span style="color:#f92672">.</span>math<span style="color:#f92672">.</span>squared_difference(x, y), axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>), name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;euclid_dist&#34;</span>)


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f_distance</span>(gxy_pos, halo_pos, c):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Tensorflow Tensor 대신에 Numpy의 형식으로 원소간 최댓값을 출력합니다.
</span><span style="color:#e6db74">    
</span><span style="color:#e6db74">    Args:
</span><span style="color:#e6db74">      gxy_pos: 관측된 은하의 위치를 나타내는 2차원 numpy array
</span><span style="color:#e6db74">      halo_pos: 헤일로의 위치를 나타내는 2차원 numpy array
</span><span style="color:#e6db74">      c: 0번째 모양을 뜻하는 스칼라
</span><span style="color:#e6db74">    Returns: 
</span><span style="color:#e6db74">      은하와 헤일로 사이의 거리와 상수 c중 최댓값을 출력
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">return</span> tf<span style="color:#f92672">.</span>maximum(euclidean_distance(gxy_pos, halo_pos), c, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;f_dist&#34;</span>)[:, None]


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">tangential_distance</span>(glxy_position, halo_position):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">   은하의 위치와 헤일로의 위치 사이의 접선의 길이를 계산
</span><span style="color:#e6db74">    
</span><span style="color:#e6db74">    Args:
</span><span style="color:#e6db74">      glxy_position: 관측된 은하의 위치를 나타내는 2차원 numpy array
</span><span style="color:#e6db74">      halo_position:  헤일로의 위치를 나타내는 2차원 numpy array
</span><span style="color:#e6db74">    Returns: 
</span><span style="color:#e6db74">      가장 큰 헤일로로의 방향을 포함한 벡터
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    
    x_delta, y_delta <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>unstack(
    glxy_position <span style="color:#f92672">-</span> halo_position, num<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, axis<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>)
    angle <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.</span> <span style="color:#f92672">*</span> tf<span style="color:#f92672">.</span>atan(y_delta <span style="color:#f92672">/</span> x_delta)
    <span style="color:#66d9ef">return</span> tf<span style="color:#f92672">.</span>stack([<span style="color:#f92672">-</span>tf<span style="color:#f92672">.</span>cos(angle), <span style="color:#f92672">-</span>tf<span style="color:#f92672">.</span>sin(angle)], axis<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;tan_dist&#39;</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">posterior_log_prob</span>(mass_large, halo_pos):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    상태 함수로 나타낸 우리의 사후 로그 확률
</span><span style="color:#e6db74">    Closure over: 데이터
</span><span style="color:#e6db74">    
</span><span style="color:#e6db74">    Args:
</span><span style="color:#e6db74">      mass_large: 상태에서 가져온 헤일로의 크기 sclar값
</span><span style="color:#e6db74">      halo_pos: 상태에서 가져온 헤일로 위치의 tensor
</span><span style="color:#e6db74">    Returns: 
</span><span style="color:#e6db74">      로그 확률들의 합을 나타내는 scalar값
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    rv_mass_large <span style="color:#f92672">=</span> tfd<span style="color:#f92672">.</span>Uniform(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;rv_mass_large&#39;</span>, low<span style="color:#f92672">=</span><span style="color:#ae81ff">40.</span>, high<span style="color:#f92672">=</span><span style="color:#ae81ff">180.</span>)    
    
    <span style="color:#75715e">#헤일로의 크기에 대해서 무작위 사이즈를 설정(여기서는 가장 큰 헤일로)</span>
    <span style="color:#75715e"># tfd.Independent 를 사용해 batch와 event의 모양을 바꿉시다</span>
    rv_halo_pos <span style="color:#f92672">=</span> tfd<span style="color:#f92672">.</span>Independent(tfd<span style="color:#f92672">.</span>Uniform(
                                       low<span style="color:#f92672">=</span>[<span style="color:#ae81ff">0.</span>, <span style="color:#ae81ff">0.</span>],
                                       high<span style="color:#f92672">=</span>[<span style="color:#ae81ff">4200.</span>, <span style="color:#ae81ff">4200.</span>]),
                           reinterpreted_batch_ndims<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;rv_halo_position&#39;</span>)
    ellpty_mvn_loc <span style="color:#f92672">=</span> (mass_large <span style="color:#f92672">/</span>
                      f_distance(data[:, :<span style="color:#ae81ff">2</span>], halo_pos, <span style="color:#ae81ff">240.</span>) <span style="color:#f92672">*</span>
                      tangential_distance(data[:, :<span style="color:#ae81ff">2</span>], halo_pos))
    ellpty <span style="color:#f92672">=</span> tfd<span style="color:#f92672">.</span>MultivariateNormalDiag(loc<span style="color:#f92672">=</span>ellpty_mvn_loc, 
                        scale_diag<span style="color:#f92672">=</span>[<span style="color:#ae81ff">0.223607</span>, <span style="color:#ae81ff">0.223607</span>],
                        name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ellpty&#39;</span>)
    
    <span style="color:#66d9ef">return</span> (tf<span style="color:#f92672">.</span>reduce_sum(ellpty<span style="color:#f92672">.</span>log_prob(data[:, <span style="color:#ae81ff">2</span>:]), axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> 
            rv_halo_pos<span style="color:#f92672">.</span>log_prob(halo_pos) <span style="color:#f92672">+</span> 
            rv_mass_large<span style="color:#f92672">.</span>log_prob(mass_large))

</code></pre></div><p>다음 파트로 이동합시다.</p>
<p><strong>암흑 물질 헤일로의 위치가 주어졌을 때 데이터(관측된 은하들의 타원인 정도) 의 확률론적인 모델 $p(e|x)$을 만듭니다.</strong></p>
<p>주어진 데이터에서 우리는 Metropolis Random Walk(MRW) MCMC 방법을 사용해 모델의 모수에 대한 정확한 사후 분포를 계산할 것입니다. 이런 종류의 문제에 HMC를 사용할 수도 있지만, 여기서는 Metropolis가 상대적으로 간단하기 때문에 이 케이스에는 적절합니다.</p>
<p>Tim의 모델은 우리에게 시작점으로 사용될 근사 사후 분포를 줍니다. 즉, 우리는 은하의 타원도에 따라 사후 분포가 반드시 거리의 정규 분포에 비례할것이라고 추측합니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 사후 분포를 추론합시다.</span>

number_of_steps <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000</span>
burnin <span style="color:#f92672">=</span> <span style="color:#ae81ff">5000</span>

<span style="color:#75715e"># 체인의 시작점을 설정합니다.</span>
initial_chain_state <span style="color:#f92672">=</span> [
    tf<span style="color:#f92672">.</span>fill([<span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">80.</span>,  name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;init_mass_large&#34;</span>),
    tf<span style="color:#f92672">.</span>fill([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], <span style="color:#ae81ff">2100.</span>, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;init_halo_pos&#34;</span>)
]

<span style="color:#75715e"># HMC가 과도하게 제약 없는 공간 위에서 실행되기 때문에, 샘플들이</span>
<span style="color:#75715e"># 현실적인 값이 나오도록 변환할 필요가 있습니다.</span>
unconstraining_bijectors <span style="color:#f92672">=</span> [
    tfp<span style="color:#f92672">.</span>bijectors<span style="color:#f92672">.</span>Identity(),
    tfp<span style="color:#f92672">.</span>bijectors<span style="color:#f92672">.</span>Identity()
]

<span style="color:#75715e"># 우리의 결합 로그 분포에 대한 클로져를 만듭니다.</span>
unnormalized_posterior_log_prob <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> <span style="color:#f92672">*</span>args: posterior_log_prob( <span style="color:#f92672">*</span>args)


<span style="color:#75715e"># HMC 체인을 만듭시다.</span>

kernel <span style="color:#f92672">=</span> tfp<span style="color:#f92672">.</span>mcmc<span style="color:#f92672">.</span>HamiltonianMonteCarlo(
        target_log_prob_fn<span style="color:#f92672">=</span>unnormalized_posterior_log_prob,
        num_leapfrog_steps<span style="color:#f92672">=</span><span style="color:#ae81ff">6</span>,
        step_size<span style="color:#f92672">=</span><span style="color:#ae81ff">0.06</span>)

kernel <span style="color:#f92672">=</span> tfp<span style="color:#f92672">.</span>mcmc<span style="color:#f92672">.</span>TransformedTransitionKernel(
    inner_kernel<span style="color:#f92672">=</span>kernel,
    bijector<span style="color:#f92672">=</span>unconstraining_bijectors)

kernel <span style="color:#f92672">=</span> tfp<span style="color:#f92672">.</span>mcmc<span style="color:#f92672">.</span>SimpleStepSizeAdaptation(
    inner_kernel<span style="color:#f92672">=</span>kernel, num_adaptation_steps<span style="color:#f92672">=</span>int(burnin <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.8</span>))

<span style="color:#75715e"># 체인으로부터 샘플링합시다.</span>
[
    mass_large, 
    posterior_predictive_samples
], kernel_results <span style="color:#f92672">=</span> tfp<span style="color:#f92672">.</span>mcmc<span style="color:#f92672">.</span>sample_chain(
    num_results <span style="color:#f92672">=</span> number_of_steps,
    num_burnin_steps <span style="color:#f92672">=</span> burnin,
    current_state<span style="color:#f92672">=</span>initial_chain_state,
    kernel<span style="color:#f92672">=</span>kernel)
</code></pre></div><p>이제 우리의 새로운 확률론적인 모델을 만들었습니다. 이제 세 번째 단계로 갑시다.</p>
<p><strong>베이즈 룰을 사용해 헤일로 위치의 사후 분포를 만듭니다. 즉 데이터를 사용해 암흑 물질 헤일로가 어디에 있을지 추측합니다.</strong></p>
<p>MCMC의 결과물들에서 평균과 표준편차를 가지고 헤일로 분포의 저차원 다변량 정규 분포를 만들것입니다. 이것이 우리의 사후 예측 분포가 될 것입니다.</p>
<p>첫 번째로, 우리는 세션을 설정하기 위해 편리한 함수를 만들 수 있습니다.</p>
<p>이제 결과를 <code>evaluate</code>함수를 사용해 실행하고 우리의 예측과 맞는시 확인합시다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 계산을 실행합시다</span>
<span style="color:#75715e"># evaluate 함수 생성</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">evaluate</span>(tensors):
    <span style="color:#66d9ef">if</span> tf<span style="color:#f92672">.</span>executing_eagerly():
         <span style="color:#66d9ef">return</span> tf<span style="color:#f92672">.</span>nest<span style="color:#f92672">.</span>pack_sequence_as(
             tensors,
             [t<span style="color:#f92672">.</span>numpy() <span style="color:#66d9ef">if</span> tf<span style="color:#f92672">.</span>is_tensor(t) <span style="color:#66d9ef">else</span> t
             <span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> tf<span style="color:#f92672">.</span>nest<span style="color:#f92672">.</span>flatten(tensors)])
    <span style="color:#66d9ef">with</span> tf<span style="color:#f92672">.</span>Session() <span style="color:#66d9ef">as</span> sess:
        <span style="color:#66d9ef">return</span> sess<span style="color:#f92672">.</span>run(tensors)
        
[
    posterior_predictive_samples_,
    kernel_results_,
] <span style="color:#f92672">=</span> evaluate([
    posterior_predictive_samples,
    kernel_results,
])

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;acceptance rate: {}&#34;</span><span style="color:#f92672">.</span>format(
    kernel_results_<span style="color:#f92672">.</span>inner_results<span style="color:#f92672">.</span>inner_results<span style="color:#f92672">.</span>is_accepted<span style="color:#f92672">.</span>mean()))

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;final step size: {}&#34;</span><span style="color:#f92672">.</span>format(
    kernel_results_<span style="color:#f92672">.</span>new_step_size[<span style="color:#f92672">-</span><span style="color:#ae81ff">100</span>:]<span style="color:#f92672">.</span>mean()))

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;posterior_predictive_samples_ value: </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74"> {}&#34;</span><span style="color:#f92672">.</span>format(
    posterior_predictive_samples_))
</code></pre></div><pre><code>acceptance rate: 0.7755
final step size: 19.64212417602539
posterior_predictive_samples_ value: 
 [[[2313.9478 1139.5944]]

 [[2322.619  1079.6536]]

 [[2356.1804 1141.7454]]

 ...

 [[2330.2827 1165.2723]]

 [[2324.8525 1087.1661]]

 [[2347.9294 1157.0153]]]
</code></pre>
<p>밑에서 우리의 사후 예측 분포의 &ldquo;히트맵&quot;을 그려보겠습니다.(단지 사후 분포의 scatter plot이지만, 히트맵으로 시각화할 수 있습니다.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">t <span style="color:#f92672">=</span> posterior_predictive_samples_<span style="color:#f92672">.</span>reshape(number_of_steps,<span style="color:#ae81ff">2</span>)
fig <span style="color:#f92672">=</span> draw_sky(data)
plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;Galaxy positions and ellipcities of sky </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">.&#34;</span> <span style="color:#f92672">%</span> n_sky)
plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;x-position&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;y-position&#34;</span>)
plt<span style="color:#f92672">.</span>scatter(t[:,<span style="color:#ae81ff">0</span>], t[:,<span style="color:#ae81ff">1</span>], alpha <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.015</span>, c <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;#F15854&#34;</span>) <span style="color:#75715e"># Red</span>
plt<span style="color:#f92672">.</span>xlim(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4200</span>)
plt<span style="color:#f92672">.</span>ylim(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4200</span>);
</code></pre></div><p><img src="https://user-images.githubusercontent.com/57588650/93846443-003b1500-fcdf-11ea-85ab-99293f0c67ae.png" alt="output_30_0"></p>
<p>가장 확률이 높은 지점이 상처와 같은 모양으로 붉게 표시됐습니다.</p>
<p><code>./data/Training_halos.csv</code>에 있는 각각의 하늘의 데이터는 최대 세 개의 암흑물질 위치 정보를 포함하고 있습니다. 예를 들어 우리가 훈련시킨 밤하늘에는 다음과 같은 헤일로 위치를 가지고 있습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">halo_data <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>genfromtxt(<span style="color:#e6db74">&#34;data/Training_halos.csv&#34;</span>, 
                          delimiter <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;,&#34;</span>,
                          usecols <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>],
                          skip_header <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>)
<span style="color:#66d9ef">print</span>(halo_data[n_sky])
</code></pre></div><pre><code>[3.00000e+00 2.78145e+03 1.40691e+03 3.08163e+03 1.15611e+03 2.28474e+03
 3.19597e+03 1.80916e+03 8.45180e+02]
</code></pre>
<p>세 번째와 네 번째 칼럼은 헤일로의 실제 $x,y$를 나타냅니다. 이걸 위의 그래프에 표시하면, 우리의 베이지안 방법이 실제 헤일로와 거의 비슷한 위치로 예측했다는 것을 알 수 있습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">fig <span style="color:#f92672">=</span> draw_sky(data)
plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;Galaxy positions and ellipcities of sky </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">.&#34;</span> <span style="color:#f92672">%</span> n_sky)
plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;x-position&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;y-position&#34;</span>)
plt<span style="color:#f92672">.</span>scatter(t[:,<span style="color:#ae81ff">0</span>], t[:,<span style="color:#ae81ff">1</span>], alpha <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.015</span>, c <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;#F15854&#34;</span>) <span style="color:#75715e"># Red</span>
plt<span style="color:#f92672">.</span>scatter(halo_data[n_sky<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>], halo_data[n_sky<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">4</span>], 
            label <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;True halo position&#34;</span>,
            c <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;k&#34;</span>, s <span style="color:#f92672">=</span> <span style="color:#ae81ff">70</span>)
plt<span style="color:#f92672">.</span>legend(scatterpoints <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, loc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;lower left&#34;</span>)
plt<span style="color:#f92672">.</span>xlim(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4200</span>)
plt<span style="color:#f92672">.</span>ylim(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4200</span>);

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;True halo location:&#34;</span>, halo_data[n_sky][<span style="color:#ae81ff">3</span>], halo_data[n_sky][<span style="color:#ae81ff">4</span>])
</code></pre></div><pre><code>True halo location: 1408.61 1685.86
</code></pre>
<p><img src="https://user-images.githubusercontent.com/57588650/93846445-016c4200-fcdf-11ea-929d-764e529f8466.png" alt="output_34_1"></p>
<p>완벽합니다. 우리의 다음 단계는 손실함수를 사용해 우리의 위치를 최적화하는 것입니다. 단순한 방법은 그냥 평균값을 선택하는 것입니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">mean_posterior <span style="color:#f92672">=</span> t<span style="color:#f92672">.</span>mean(axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Mean Posterior: </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74"> {}&#34;</span><span style="color:#f92672">.</span>format(mean_posterior[<span style="color:#ae81ff">0</span>]))
</code></pre></div><pre><code>Mean Posterior: 
 [2324.299  1123.6595]
</code></pre>
<p>그러나 우리는 이 평균값의 스코어가 얼마나 좋은지를 알고싶습니다. <a href="https://github.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/blob/master/Chapter5_LossFunctions/DarkWorldsMetric.py">DarkWorldsMetric.py</a>를 통해 판단해보죠.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">url <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;https://raw.githubusercontent.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/master/Chapter5_LossFunctions/DarkWorldsMetric.py&#39;</span>
filename <span style="color:#f92672">=</span> wget<span style="color:#f92672">.</span>download(url)
filename
</code></pre></div><pre><code>'DarkWorldsMetric.py'
</code></pre>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> DarkWorldsMetric <span style="color:#f92672">import</span> main_score

halo_data_sub <span style="color:#f92672">=</span> halo_data[n_sky<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]

nhalo_all  <span style="color:#f92672">=</span> halo_data_sub[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>)
x_true_all <span style="color:#f92672">=</span> halo_data_sub[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>)
y_true_all <span style="color:#f92672">=</span> halo_data_sub[<span style="color:#ae81ff">4</span>]<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>)
x_ref_all  <span style="color:#f92672">=</span> halo_data_sub[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>)
y_ref_all  <span style="color:#f92672">=</span> halo_data_sub[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>)
sky_prediction <span style="color:#f92672">=</span> mean_posterior

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;평균을 사용했을 때:&#34;</span>, sky_prediction[<span style="color:#ae81ff">0</span>])
main_score(nhalo_all, x_true_all, y_true_all,
            x_ref_all, y_ref_all, sky_prediction)

<span style="color:#75715e"># 그렇다면 나쁜 스코어는 몇일까요?</span>
random_guess <span style="color:#f92672">=</span> tfd<span style="color:#f92672">.</span>Independent(tfd<span style="color:#f92672">.</span>Uniform(
                                       low<span style="color:#f92672">=</span>[<span style="color:#ae81ff">0.</span>, <span style="color:#ae81ff">0.</span>],
                                       high<span style="color:#f92672">=</span>[<span style="color:#ae81ff">4200.</span>, <span style="color:#ae81ff">4200.</span>]),
                               reinterpreted_batch_ndims<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, 
                               name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;rv_halo_position&#39;</span>)<span style="color:#f92672">.</span>sample()
random_guess_ <span style="color:#f92672">=</span> evaluate([random_guess])

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74"> 무작위 위치를 사용했을 떄:&#34;</span>, random_guess_[<span style="color:#ae81ff">0</span>])
main_score(nhalo_all, x_true_all, y_true_all,
            x_ref_all, y_ref_all, random_guess_)
</code></pre></div><pre><code>평균을 사용했을 때: [2324.299  1123.6595]
Your average distance in pixels you are away from the true halo is 42.57065669355828
Your average angular vector is 1.0
Your score for the training data is 1.0425706566935582

 무작위 위치를 사용했을 떄: [3742.3608 3335.713 ]
Your average distance in pixels you are away from the true halo is 2667.317015236032
Your average angular vector is 1.0
Your score for the training data is 3.667317015236032





3.667317015236032
</code></pre>
<p>무작위 위치를 사용했을 때 보다 훨씬 거리가 작기 때문에 이것은 좋은 예측입니다, 실제 위치에서 그렇게 멀리 떨어져있지 않죠. 그러나 이것은 우리에게 주어진 손실 함수를 무시합니다. 우리는 또한 최대 두개의 추가적인 작은 헤일로들로 우리의 코드를 확장해야합니다. 전에 했던 TensorFlow Workflow를 자동으로 수행하는 코드를 만듭시다.</p>
<p>처음으로 새로운 데이터셋을 넣습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">n_sky <span style="color:#f92672">=</span> <span style="color:#ae81ff">215</span>             <span style="color:#75715e">#file/sky 을 실험을 위해 선택합시다.</span>
data <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>genfromtxt(<span style="color:#e6db74">&#34;data/Train_Skies/Train_Skies/</span><span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span><span style="color:#e6db74">Training_Sky</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">.csv&#34;</span> <span style="color:#f92672">%</span> (n_sky),
                      dtype <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>float32,
                      skip_header <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
                      delimiter <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;,&#34;</span>,
                      usecols <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>])
            

galaxy_positions <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(data[:, :<span style="color:#ae81ff">2</span>], dtype<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>float32)
gal_ellipticities <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(data[:, <span style="color:#ae81ff">2</span>:], dtype<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>float32)
ellipticity_mean <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>mean(data[:, <span style="color:#ae81ff">2</span>:], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
ellipticity_stddev <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>std(data[:, <span style="color:#ae81ff">2</span>:], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
num_galaxies <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(galaxy_positions)<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;하늘 </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">에서의 은하수 데이터.&#34;</span><span style="color:#f92672">%</span>n_sky)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;position_x, position_y, e_1, e_2 &#34;</span>)
<span style="color:#66d9ef">print</span>(data[:<span style="color:#ae81ff">3</span>])
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;은하수의 갯수: &#34;</span>, num_galaxies)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;e_1 &amp; e_2 평균: &#34;</span>, ellipticity_mean)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;e_1 &amp; e_2 표준편차: &#34;</span>, ellipticity_stddev)

</code></pre></div><pre><code>하늘 215에서의 은하수 데이터.
position_x, position_y, e_1, e_2 
[[ 3.90340e+03  1.38480e+03 -4.93760e-02  1.73814e-01]
 [ 1.75626e+03  1.64510e+03  4.09440e-02  1.90665e-01]
 [ 3.81832e+03  3.18108e+03  1.97530e-01 -2.10599e-01]]
은하수의 갯수:  449
e_1 &amp; e_2 평균:  [ 0.01484613 -0.02457484]
e_1 &amp; e_2 표준편차:  [0.20280695 0.20415685]
</code></pre>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">multi_posterior_log_prob</span>(mass_large_, halo_pos_):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    상태함수로써의 우리의 수정된 사후 로그 확률
</span><span style="color:#e6db74">    Closure over: data
</span><span style="color:#e6db74">    
</span><span style="color:#e6db74">    Args:
</span><span style="color:#e6db74">      mass_large_: 상태에서 온 헤일로의 크기 scalar
</span><span style="color:#e6db74">      halo_pos_: 상태에서 온 헤일로의 포지션 tensor
</span><span style="color:#e6db74">    Closure over: 
</span><span style="color:#e6db74">      data
</span><span style="color:#e6db74">    Returns: 
</span><span style="color:#e6db74">     로그 확률들의 합 scalar
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#75715e"># 헤일로의 크기에 무작위 값을 설정 (큰거 하나, 작은거 두 개로 하죠)</span>
    rv_mass_large <span style="color:#f92672">=</span> tfd<span style="color:#f92672">.</span>Uniform(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;rv_mass_large&#39;</span>, low<span style="color:#f92672">=</span><span style="color:#ae81ff">40.</span>, high<span style="color:#f92672">=</span><span style="color:#ae81ff">180.</span>)    
    rv_mass_small_1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">20.</span>
    rv_mass_small_2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">20.</span>
             
    <span style="color:#75715e"># 헤일로 위치의 최초 사전 분포</span>
    <span style="color:#75715e"># 2차원 균등 분포의 집합으로 설정합니다.</span>

    rv_halo_pos <span style="color:#f92672">=</span> tfd<span style="color:#f92672">.</span>Independent(tfd<span style="color:#f92672">.</span>Uniform(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;rv_halo_positions&#34;</span>,
                                         low<span style="color:#f92672">=</span>tf<span style="color:#f92672">.</span>cast(np<span style="color:#f92672">.</span>reshape(
                                             np<span style="color:#f92672">.</span>tile([<span style="color:#ae81ff">0.</span>, <span style="color:#ae81ff">0.</span>],
                                                     n_halos_in_sky),
                                             [n_halos_in_sky, <span style="color:#ae81ff">2</span>]), tf<span style="color:#f92672">.</span>float32),
                                         high<span style="color:#f92672">=</span>tf<span style="color:#f92672">.</span>cast(np<span style="color:#f92672">.</span>reshape(
                                             np<span style="color:#f92672">.</span>tile([<span style="color:#ae81ff">4200.</span>, <span style="color:#ae81ff">4200.</span>],
                                                     n_halos_in_sky),
                                             [n_halos_in_sky, <span style="color:#ae81ff">2</span>]), tf<span style="color:#f92672">.</span>float32)),
                             reinterpreted_batch_ndims<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e"># 이 크기에 주목하세요</span>
      
    fdist_constants <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">240.</span>, <span style="color:#ae81ff">70.</span>, <span style="color:#ae81ff">70.</span>])
       
    <span style="color:#75715e"># 헤일로 위치로부터 타원성을 계산하기 위해, 우리는 여러개 헤일로부터 온 힘들의 평균의 합을 기반으로</span>
    <span style="color:#75715e"># 평균을 계산할 것입니다.</span>
    mean_sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    mean_sum <span style="color:#f92672">+=</span> (mass_large_[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">/</span> f_distance(data[:,:<span style="color:#ae81ff">2</span>], halo_pos_[<span style="color:#ae81ff">0</span>, :], fdist_constants[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">*</span>
            tangential_distance(data[:,:<span style="color:#ae81ff">2</span>], halo_pos_[<span style="color:#ae81ff">0</span>, :]))
    mean_sum <span style="color:#f92672">+=</span> (rv_mass_small_1 <span style="color:#f92672">/</span> f_distance(data[:,:<span style="color:#ae81ff">2</span>], halo_pos_[<span style="color:#ae81ff">1</span>, :], fdist_constants[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">*</span>
            tangential_distance(data[:,:<span style="color:#ae81ff">2</span>], halo_pos_[<span style="color:#ae81ff">1</span>, :]))
    mean_sum <span style="color:#f92672">+=</span> (rv_mass_small_2 <span style="color:#f92672">/</span> f_distance(data[:,:<span style="color:#ae81ff">2</span>], halo_pos_[<span style="color:#ae81ff">2</span>, :], fdist_constants[<span style="color:#ae81ff">2</span>]) <span style="color:#f92672">*</span>
            tangential_distance(data[:,:<span style="color:#ae81ff">2</span>], halo_pos_[<span style="color:#ae81ff">2</span>, :]))
        
    ellpty <span style="color:#f92672">=</span> tfd<span style="color:#f92672">.</span>MultivariateNormalDiag(loc<span style="color:#f92672">=</span>(mean_sum), scale_diag<span style="color:#f92672">=</span>[<span style="color:#ae81ff">0.223607</span>, <span style="color:#ae81ff">0.223607</span>], name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ellpty&#39;</span>)

    <span style="color:#66d9ef">return</span> (tf<span style="color:#f92672">.</span>reduce_sum(ellpty<span style="color:#f92672">.</span>log_prob(data[:, <span style="color:#ae81ff">2</span>:]), axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> 
            rv_halo_pos<span style="color:#f92672">.</span>log_prob(tf<span style="color:#f92672">.</span>cast(halo_pos_[<span style="color:#ae81ff">0</span>, :], tf<span style="color:#f92672">.</span>float32))[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> 
            rv_halo_pos<span style="color:#f92672">.</span>log_prob(tf<span style="color:#f92672">.</span>cast(halo_pos_[<span style="color:#ae81ff">1</span>, :], tf<span style="color:#f92672">.</span>float32))[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span>
            rv_halo_pos<span style="color:#f92672">.</span>log_prob(tf<span style="color:#f92672">.</span>cast(halo_pos_[<span style="color:#ae81ff">2</span>, :], tf<span style="color:#f92672">.</span>float32))[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> 
            rv_mass_large<span style="color:#f92672">.</span>log_prob(tf<span style="color:#f92672">.</span>cast(mass_large_[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>], tf<span style="color:#f92672">.</span>float32)))
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
number_of_steps <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000</span> <span style="color:#75715e">#</span>
burnin <span style="color:#f92672">=</span> <span style="color:#ae81ff">2500</span> 
leapfrog_steps<span style="color:#f92672">=</span><span style="color:#ae81ff">6</span> 
    
<span style="color:#75715e"># 3개의 헤일로가 하늘에 있습니다.</span>
n_halos_in_sky <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>

<span style="color:#75715e"># 체인의 시작 상태를 설정합니다..</span>
initial_chain_state <span style="color:#f92672">=</span> [
    tf<span style="color:#f92672">.</span>constant([<span style="color:#ae81ff">80.</span>, <span style="color:#ae81ff">20.</span>, <span style="color:#ae81ff">20.</span>], shape<span style="color:#f92672">=</span>[n_halos_in_sky, <span style="color:#ae81ff">1</span>], 
                dtype<span style="color:#f92672">=</span>tf<span style="color:#f92672">.</span>float32, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;init_mass_large_multi&#34;</span>),
    tf<span style="color:#f92672">.</span>constant([<span style="color:#ae81ff">1000.</span>, <span style="color:#ae81ff">500.</span>, <span style="color:#ae81ff">2100.</span>, <span style="color:#ae81ff">1500.</span>, <span style="color:#ae81ff">3500.</span>, <span style="color:#ae81ff">4000.</span>], 
                shape<span style="color:#f92672">=</span>[n_halos_in_sky,<span style="color:#ae81ff">2</span>], 
                dtype<span style="color:#f92672">=</span>tf<span style="color:#f92672">.</span>float32, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;init_halo_pos_multi&#34;</span>)
]

<span style="color:#75715e"># HMC가 과도하게 제약 없는 공간 위에서 실행되기 때문에, 샘플들이</span>
<span style="color:#75715e"># 현실적인 값이 나오도록 변환할 필요가 있습니다.</span>
unconstraining_bijectors <span style="color:#f92672">=</span> [
    tfp<span style="color:#f92672">.</span>bijectors<span style="color:#f92672">.</span>Identity(),
    tfp<span style="color:#f92672">.</span>bijectors<span style="color:#f92672">.</span>Identity()
]

<span style="color:#75715e"># 우리의 결합 로그 확률에 대해 클로져를 정의합니다..</span>
unnormalized_posterior_log_prob <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> <span style="color:#f92672">*</span>args: multi_posterior_log_prob( <span style="color:#f92672">*</span>args)


<span style="color:#75715e"># HMC를 정의합시다.</span>
kernel<span style="color:#f92672">=</span>tfp<span style="color:#f92672">.</span>mcmc<span style="color:#f92672">.</span>TransformedTransitionKernel(
    inner_kernel<span style="color:#f92672">=</span>tfp<span style="color:#f92672">.</span>mcmc<span style="color:#f92672">.</span>HamiltonianMonteCarlo(
        target_log_prob_fn<span style="color:#f92672">=</span>unnormalized_posterior_log_prob,
        num_leapfrog_steps<span style="color:#f92672">=</span>leapfrog_steps,
        step_size<span style="color:#f92672">=</span><span style="color:#ae81ff">0.6</span>,
        state_gradients_are_stopped<span style="color:#f92672">=</span>True),
    bijector<span style="color:#f92672">=</span>unconstraining_bijectors)

kernel <span style="color:#f92672">=</span> tfp<span style="color:#f92672">.</span>mcmc<span style="color:#f92672">.</span>SimpleStepSizeAdaptation(
    inner_kernel<span style="color:#f92672">=</span>kernel, num_adaptation_steps<span style="color:#f92672">=</span>int(burnin <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.8</span>))

<span style="color:#75715e"># 체인에서 표본을 뽑습니다.</span>
[
    mass_large, 
    halo_pos
], kernel_results <span style="color:#f92672">=</span> tfp<span style="color:#f92672">.</span>mcmc<span style="color:#f92672">.</span>sample_chain(
    num_results <span style="color:#f92672">=</span> number_of_steps,
    num_burnin_steps <span style="color:#f92672">=</span> burnin,
    current_state<span style="color:#f92672">=</span>initial_chain_state,
    kernel<span style="color:#f92672">=</span>kernel)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">large_halo_pos <span style="color:#f92672">=</span> halo_pos[:,<span style="color:#ae81ff">0</span>]
small1_halo_pos <span style="color:#f92672">=</span> halo_pos[:,<span style="color:#ae81ff">1</span>]
small2_halo_pos <span style="color:#f92672">=</span> halo_pos[:,<span style="color:#ae81ff">2</span>]
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 우리의 계산을 실행합시다.</span>
<span style="color:#75715e"># evaluate 함수 생성</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">evaluate</span>(tensors):
    <span style="color:#66d9ef">if</span> tf<span style="color:#f92672">.</span>executing_eagerly():
         <span style="color:#66d9ef">return</span> tf<span style="color:#f92672">.</span>nest<span style="color:#f92672">.</span>pack_sequence_as(
             tensors,
             [t<span style="color:#f92672">.</span>numpy() <span style="color:#66d9ef">if</span> tf<span style="color:#f92672">.</span>is_tensor(t) <span style="color:#66d9ef">else</span> t
             <span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> tf<span style="color:#f92672">.</span>nest<span style="color:#f92672">.</span>flatten(tensors)])
    <span style="color:#66d9ef">with</span> tf<span style="color:#f92672">.</span>Session() <span style="color:#66d9ef">as</span> sess:
        <span style="color:#66d9ef">return</span> sess<span style="color:#f92672">.</span>run(tensors)

        
[
    large_halo_pos_,
    small1_halo_pos_,
    small2_halo_pos_,
    kernel_results_
] <span style="color:#f92672">=</span> evaluate([
    large_halo_pos,
    small1_halo_pos,
    small2_halo_pos,
    kernel_results
])
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">fig <span style="color:#f92672">=</span> draw_sky(data)
plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;Galaxy positions and ellipcities of sky </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">.&#34;</span> <span style="color:#f92672">%</span> n_sky)
plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;x-position&#34;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;y-position&#34;</span>)

<span style="color:#75715e"># 빨강, 보라, 오렌지로 색을 칠합시다</span>
colors <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;#F15854&#34;</span>, <span style="color:#e6db74">&#34;#B276B2&#34;</span>, <span style="color:#e6db74">&#34;#FAA43A&#34;</span>]


t1 <span style="color:#f92672">=</span> large_halo_pos_
t2 <span style="color:#f92672">=</span> small1_halo_pos_
t3 <span style="color:#f92672">=</span> small2_halo_pos_

plt<span style="color:#f92672">.</span>scatter(t1[:,<span style="color:#ae81ff">0</span>], t1[:,<span style="color:#ae81ff">1</span>], alpha <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.015</span>, c <span style="color:#f92672">=</span> colors[<span style="color:#ae81ff">0</span>])
plt<span style="color:#f92672">.</span>scatter(t2[:,<span style="color:#ae81ff">0</span>], t2[:,<span style="color:#ae81ff">1</span>], alpha <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.015</span>, c <span style="color:#f92672">=</span> colors[<span style="color:#ae81ff">1</span>])
plt<span style="color:#f92672">.</span>scatter(t3[:,<span style="color:#ae81ff">0</span>], t3[:,<span style="color:#ae81ff">1</span>], alpha <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.015</span>, c <span style="color:#f92672">=</span> colors[<span style="color:#ae81ff">2</span>])
    
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">3</span>):
    plt<span style="color:#f92672">.</span>scatter(halo_data[n_sky<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>i], halo_data[n_sky<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>i], 
            label <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;True halo position&#34;</span>, c <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;k&#34;</span>, s <span style="color:#f92672">=</span> <span style="color:#ae81ff">90</span>)
    
<span style="color:#75715e">#plt.legend(scatterpoints = 1)</span>
plt<span style="color:#f92672">.</span>xlim(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4200</span>)
plt<span style="color:#f92672">.</span>ylim(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4200</span>);
</code></pre></div><p><img src="https://user-images.githubusercontent.com/57588650/93846450-029d6f00-fcdf-11ea-818c-02dc17be3898.png" alt="output_46_0"></p>
<p>수렴하는데 너무 오래 걸리긴 하지만 꽤 괜찮게 보입니다. 우리의 최적화 단계는 다음과 같이 생겼을 것입니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> DarkWorldsMetric <span style="color:#f92672">import</span> main_score

halo_data_sub <span style="color:#f92672">=</span> halo_data[n_sky <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]


halo_lar_mean_ <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>mean(large_halo_pos_,axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
halo_sm1_mean_ <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>mean(small1_halo_pos_,axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) 
halo_sm2_mean_ <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>mean(small2_halo_pos_,axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)

mean_posterior <span style="color:#f92672">=</span> [np<span style="color:#f92672">.</span>concatenate([halo_lar_mean_, halo_sm1_mean_, halo_sm2_mean_])]

nhalo_all  <span style="color:#f92672">=</span> halo_data_sub[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)
x_true_all <span style="color:#f92672">=</span> halo_data_sub[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)
y_true_all <span style="color:#f92672">=</span> halo_data_sub[<span style="color:#ae81ff">4</span>]<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)
x_ref_all  <span style="color:#f92672">=</span> halo_data_sub[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)
y_ref_all  <span style="color:#f92672">=</span> halo_data_sub[<span style="color:#ae81ff">4</span>]<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)
sky_prediction1 <span style="color:#f92672">=</span> mean_posterior[<span style="color:#ae81ff">0</span>][:<span style="color:#ae81ff">2</span>]
sky_prediction2 <span style="color:#f92672">=</span> mean_posterior[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">4</span>]
sky_prediction3 <span style="color:#f92672">=</span> mean_posterior[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">4</span>:]

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;평균을 사용했을 때:&#34;</span>, 
      sky_prediction1, 
      sky_prediction2, 
      sky_prediction3)
main_score([<span style="color:#ae81ff">1</span>], x_true_all, y_true_all,
           x_ref_all, y_ref_all, [sky_prediction3])

<span style="color:#75715e"># 나쁜 스코어는 어떨까?</span>
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
random_guess <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4200</span>, size<span style="color:#f92672">=</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>))
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;무작위 위치를 사용했을 때 :&#34;</span>, random_guess[<span style="color:#ae81ff">0</span>])
main_score([<span style="color:#ae81ff">1</span>], x_true_all, y_true_all,
           x_ref_all, y_ref_all, random_guess)
</code></pre></div><pre><code>평균을 사용했을 때: [829.1702  660.53644] [2635.6897 1497.5631] [3321.5366 3857.1504]
Your average distance in pixels you are away from the true halo is 384.39184643144546
Your average angular vector is 0.9999999999999999
Your score for the training data is 1.3843918464314453


무작위 위치를 사용했을 때 : [ 750 1572]
Your average distance in pixels you are away from the true halo is 3781.342469877596
Your average angular vector is 1.0
Your score for the training data is 4.781342469877597





4.781342469877597
</code></pre>
<h2 id="references">References</h2>
<p>Antifragile: Things That Gain from Disorder. New York: Random House. 2012. ISBN 978-1-4000-6782-4.</p>
<p><a href="http://www.timsalimans.com/observing-dark-worlds">Tim Saliman&rsquo;s solution to the Dark World&rsquo;s Contest</a></p>
<p>Silver, Nate. The Signal and the Noise: Why So Many Predictions Fail — but Some Don&rsquo;t. 1. Penguin Press HC, The, 2012. Print.</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/bayesian/" rel="tag">Bayesian</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/tensorflow/" rel="tag">TensorFlow</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/python/" rel="tag">Python</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<div class="authorbox__header">
		<span class="authorbox__name"></span>
	</div>
</div>



			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2021 Tai Hwan Oh.
			<span class="footer__copyright-credits"></span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>